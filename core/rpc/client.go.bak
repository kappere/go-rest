package rpc

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"flag"
	"io/ioutil"
	"math/rand"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"time"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	k8srest "k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/util/homedir"

	"wataru.com/go-rest/core/logger"
	"wataru.com/go-rest/core/rest"
)

var rpcConf *rest.RpcConfig

var srvLookup func(srvname string) *RpcService

var srvMap = make(map[string]*RpcService)

type RpcService struct {
	Name string
	Addr string
}

func InitClient(c *rest.RpcConfig) {
	rpcConf = c

	if rpcConf.Type == "kubernetes" {
		if isInKubernetesCluster() {
			// 需要先添加service读取权限
			// kubectl create clusterrolebinding service-reader-pod --clusterrole=service-reader --serviceaccount=default:default

			// creates the in-cluster config
			config, err := k8srest.InClusterConfig()
			if err != nil {
				panic(err.Error())
			}
			logger.Info("in kubernetes [%s]", config.Host)

			// creates the clientset
			clientset, err := kubernetes.NewForConfig(config)
			if err != nil {
				panic(err.Error())
			}

			// TODO 获取service的IP与端口，有更好的方式
			go func() {
				for {
					fetchInnerKubernetesService(clientset, rpcConf.Kubernetes.Namespace)
					time.Sleep(60 * time.Second)
				}
			}()
			srvLookup = func(srvname string) *RpcService {
				r := srvMap[srvname]
				if r == nil {
					fetchInnerKubernetesService(clientset, rpcConf.Kubernetes.Namespace)
					r = srvMap[srvname]
				}
				return r
			}
		} else {
			var kubeconfig *string
			if home := homedir.HomeDir(); home != "" {
				kubeconfig = flag.String("kubeconfig", filepath.Join(home, ".kube", "config"), "(optional) absolute path to the kubeconfig file")
			} else {
				kubeconfig = flag.String("kubeconfig", "", "absolute path to the kubeconfig file")
			}
			flag.Parse()
			// use the current context in kubeconfig
			config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
			if err != nil {
				panic(err.Error())
			}
			logger.Info("out of kubernetes [%s]", config.Host)

			fetchProxyKubernetesService(rpcConf.Kubernetes.Proxy)
			srvLookup = func(srvname string) *RpcService {
				r := srvMap[srvname]
				if r == nil {
					r = srvMap["*"]
				}
				r.Addr = strings.ReplaceAll(r.Addr, "{namespace}", rpcConf.Kubernetes.Namespace)
				r.Addr = strings.ReplaceAll(r.Addr, "{app}", srvname)
				return r
			}
		}
	}
}

var fetchInnerKubernetesServiceLock sync.Mutex

func fetchInnerKubernetesService(clientset *kubernetes.Clientset, namespace string) {
	fetchInnerKubernetesServiceLock.Lock()
	defer fetchInnerKubernetesServiceLock.Unlock()
	tmpm := make(map[string]*RpcService)
	srvs, _ := clientset.CoreV1().Services(namespace).List(context.TODO(), metav1.ListOptions{})
	for _, srv := range srvs.Items {
		if len(srv.Spec.Ports) > 0 {
			tmpm[srv.Name] = &RpcService{
				Name: srv.Name,
				Addr: "http://" + srv.Name + ":" + strconv.FormatInt(int64(srv.Spec.Ports[0].Port), 10),
			}
		}
	}
	srvMap = tmpm
}

func fetchProxyKubernetesService(proxies map[string]string) {
	for srvname := range proxies {
		srvMap[srvname] = &RpcService{
			Name: srvname,
			Addr: proxies[srvname],
		}
	}
}

func (service *RpcService) Call(url string) interface{} {
	return httpPost(service.Addr + RPC_PREFIX + url)
}

func httpGet(url string) interface{} {
	reqest, _ := http.NewRequest("GET", url, nil)
	return apply(reqest)
}

func httpPost(url string) interface{} {
	reqest, _ := http.NewRequest("POST", url, nil)
	return apply(reqest)
}

func apply(request *http.Request) interface{} {
	client := &http.Client{}

	// 计算token
	rpcToken := rpcConf.Token
	timestamp := strconv.FormatInt(time.Now().UnixMilli(), 10)
	hash := sha256.New()
	randstr := strconv.Itoa(rand.Int())
	hash.Write([]byte(rpcToken + "#" + randstr + "#" + timestamp))
	enc := hex.EncodeToString(hash.Sum(nil))

	request.Header.Add("inner_token_enc", enc+"#"+randstr+"#"+timestamp)
	response, err := client.Do(request)
	if err != nil {
		panic(err)
	}
	defer response.Body.Close()
	bytedata, _ := ioutil.ReadAll(response.Body)
	resp := rest.Resp{}
	json.Unmarshal(bytedata, &resp)
	if !resp.Success {
		panic(resp.Message)
	}
	return resp.Data
}

func Service(srvname string) *RpcService {
	return srvLookup(srvname)
}

func isInKubernetesCluster() bool {
	return os.Getenv("KUBERNETES_SERVICE_HOST") != ""
}
